<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas AR Hand Magic üéÑ</title>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Noto+Sans+SC:wght@700&display=swap" rel="stylesheet">

    <!-- External Libraries (CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <style>
        :root {
            --primary: #ff0f0f;
            --gold: #ffd700;
            --glass: rgba(20, 20, 20, 0.8);
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* Layout */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* Hidden video element for MediaPipe processing */
        #input-video {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0; /* Hidden, we draw webcam feed to canvas plane or background */
            z-index: -1;
            transform: scaleX(-1); /* Mirror */
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas */
        }

        /* Greeting Text */
        #greeting-display {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            opacity: 0;
            text-shadow: 0 0 10px var(--gold), 0 0 20px var(--primary), 0 0 40px var(--primary);
        }
        #greeting-display.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.5);
        }
        .text-en {
            font-family: 'Dancing Script', cursive;
            font-size: 4rem;
            color: #fff;
            margin: 0;
        }
        .text-cn {
            font-family: 'Noto Sans SC', sans-serif;
            font-size: 2.5rem;
            color: #ffeaea;
            margin-top: 10px;
        }

        /* Controls Panel */
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: var(--glass);
            backdrop-filter: blur(10px);
            border-left: 2px solid var(--gold);
            padding: 20px;
            border-radius: 10px;
            color: white;
            pointer-events: auto;
            transform: translateX(0);
            transition: transform 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }
        #controls.collapsed {
            transform: translateX(340px);
        }
        .toggle-btn {
            position: absolute;
            left: -40px;
            top: 10px;
            width: 40px;
            height: 40px;
            background: var(--gold);
            border: none;
            border-radius: 5px 0 0 5px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        h2 { margin-top: 0; font-size: 1.2rem; border-bottom: 1px solid #555; padding-bottom: 10px; color: var(--gold); }
        .input-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="text"] {
            width: 100%;
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            color: white;
            padding: 8px;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button.action-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #c31432, #240b36);
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            transition: 0.2s;
        }
        button.action-btn:hover { transform: scale(1.02); }

        /* Status Bar */
        #status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            padding: 20px;
            text-align: center;
            color: #00ff88;
            font-family: monospace;
            font-size: 14px;
            pointer-events: none;
        }
        .mode-badge {
            background: rgba(0, 255, 136, 0.2);
            padding: 5px 10px;
            border-radius: 15px;
            border: 1px solid #00ff88;
            margin-left: 10px;
        }
        
        /* Loading */
        #loader {
            position: fixed;
            top:0; left:0; width:100%; height:100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--gold);
            font-size: 1.5rem;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 50px; height: 50px;
            border: 5px solid #333;
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

    </style>
</head>
<body>

    <!-- Camera Source (Hidden) -->
    <video id="input-video" playsinline></video>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Layer -->
    <div id="ui-layer">
        
        <!-- Center Text -->
        <div id="greeting-display">
            <h1 class="text-en" id="text-en">Merry Christmas</h1>
            <h2 class="text-cn" id="text-cn">Âú£ËØûÂø´‰πê</h2>
        </div>

        <!-- Controls -->
        <div id="controls">
            <button class="toggle-btn" onclick="togglePanel()">‚öôÔ∏è</button>
            <h2>üéÑ Magic Settings</h2>
            
            <div id="inputs-container">
                <!-- Generated by JS -->
            </div>

            <button class="action-btn" onclick="generateShareLink()">üîó Generate Share Link</button>
            <div id="share-result" style="margin-top:10px; font-size:0.8rem; word-break:break-all; color:#aaa;"></div>
        </div>

        <!-- Status -->
        <div id="status-bar">
            <span>Status: <span id="status-text">Initializing...</span></span>
            <span class="mode-badge" id="mode-badge">MOUSE MODE</span>
        </div>
    </div>

    <!-- Loader -->
    <div id="loader">
        <div class="spinner"></div>
        <div>Loading Holiday Magic...</div>
    </div>

    <script>
        /**
         * üéÑ GLOBAL CONFIGURATION & STATE
         */
        const CONFIG = {
            particleCount: 16000,
            coinCount: 500,
            shapes: [
                { id: 'gift', name: 'Gift Box', defaultEn: 'Surprise!', defaultCn: 'ÊÉäÂñúÁ§ºÁâ©' },
                { id: 'tree', name: 'Xmas Tree', defaultEn: 'Merry Christmas', defaultCn: 'Âú£ËØûÂø´‰πê' },
                { id: 'wreath', name: 'Wreath', defaultEn: 'Season\'s Greetings', defaultCn: 'ËäÇÊó•ÈóÆÂÄô' },
                { id: 'hat', name: 'Santa Hat', defaultEn: 'Ho Ho Ho!', defaultCn: 'Âú£ËØûËÄÅ‰∫∫Êù•‰∫Ü' },
                { id: 'cane', name: 'Candy Cane', defaultEn: 'Sweet Holidays', defaultCn: 'ÁîúËúúÂÅáÊúü' },
                { id: 'heart', name: 'Warm Heart', defaultEn: 'With Love', defaultCn: 'Áà±ÊÑèÊª°Êª°' }
            ],
            colors: {
                red: new THREE.Color(0xff0f0f),
                green: new THREE.Color(0x0f8f0f),
                gold: new THREE.Color(0xffd700),
                white: new THREE.Color(0xffffff),
                brown: new THREE.Color(0x8b4513)
            }
        };

        const STATE = {
            currentShapeIndex: 0,
            interactionMode: 'MOUSE', // 'MOUSE' or 'HAND'
            isScattering: false,
            pinchStrength: 0,
            rotationTarget: { x: 0, y: 0 },
            rotationCurrent: { x: 0, y: 0 },
            texts: [], // Will hold current text for each shape
            lastShapeChangeTime: 0
        };

        // Initialize Texts from URL or Defaults
        const urlParams = new URLSearchParams(window.location.search);
        const encodedTexts = urlParams.get('texts');
        if (encodedTexts) {
            try {
                STATE.texts = JSON.parse(decodeURIComponent(encodedTexts));
            } catch(e) { console.error("URL Parse Error"); }
        }
        
        // Fill missing texts with defaults
        if (STATE.texts.length !== CONFIG.shapes.length) {
            STATE.texts = CONFIG.shapes.map(s => ({ en: s.defaultEn, cn: s.defaultCn }));
        }

        // --- UI Initialization ---
        const inputsContainer = document.getElementById('inputs-container');
        CONFIG.shapes.forEach((shape, idx) => {
            const div = document.createElement('div');
            div.className = 'input-group';
            div.innerHTML = `
                <label>${shape.name} (${idx+1})</label>
                <input type="text" placeholder="English" value="${STATE.texts[idx].en}" oninput="updateText(${idx}, 'en', this.value)">
                <input type="text" placeholder="Chinese" value="${STATE.texts[idx].cn}" style="margin-top:5px" oninput="updateText(${idx}, 'cn', this.value)">
            `;
            inputsContainer.appendChild(div);
        });

        function updateText(idx, lang, val) {
            STATE.texts[idx][lang] = val;
            if (STATE.currentShapeIndex === idx) updateOverlayText();
        }

        function updateOverlayText() {
            const t = STATE.texts[STATE.currentShapeIndex];
            document.getElementById('text-en').innerText = t.en;
            document.getElementById('text-cn').innerText = t.cn;
        }

        function togglePanel() {
            document.getElementById('controls').classList.toggle('collapsed');
        }

        function generateShareLink() {
            const json = JSON.stringify(STATE.texts);
            const url = `${window.location.origin}${window.location.pathname}?texts=${encodeURIComponent(json)}`;
            const resDiv = document.getElementById('share-result');
            resDiv.innerText = "Link copied to clipboard!"; // Simulating copy
            navigator.clipboard.writeText(url).catch(() => {
                resDiv.innerText = "Could not copy automatically. Copy URL from browser bar.";
                window.history.pushState({}, '', url);
            });
        }

        /**
         * üìê SHAPE FACTORY (The Math)
         * Generates Position and Color buffers for particles
         */
        const ShapeFactory = {
            generate: (type) => {
                const positions = new Float32Array(CONFIG.particleCount * 3);
                const colors = new Float32Array(CONFIG.particleCount * 3);
                const p = new THREE.Vector3();
                const c = new THREE.Color();

                for (let i = 0; i < CONFIG.particleCount; i++) {
                    switch (type) {
                        case 'gift': // Cube
                            p.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).multiplyScalar(4);
                            // Color logic: Box is red, Ribbon is gold
                            if (Math.abs(p.x) < 0.5 || Math.abs(p.y) < 0.5) c.copy(CONFIG.colors.gold);
                            else c.copy(CONFIG.colors.red);
                            break;

                        case 'tree': // Cone
                            const h = Math.random() * 5; // Height 0 to 5
                            const r = (5 - h) * 0.4 * Math.sqrt(Math.random());
                            const theta = Math.random() * Math.PI * 2;
                            p.set(r * Math.cos(theta), h - 2.5, r * Math.sin(theta));
                            
                            // Decorations
                            if (Math.random() > 0.9) c.copy(Math.random() > 0.5 ? CONFIG.colors.red : CONFIG.colors.gold);
                            else c.copy(CONFIG.colors.green);
                            break;

                        case 'wreath': // Torus
                            const u = Math.random() * Math.PI * 2;
                            const v = Math.random() * Math.PI * 2;
                            const tubeR = 0.6 + Math.random() * 0.2;
                            const ringR = 2.0;
                            p.x = (ringR + tubeR * Math.cos(v)) * Math.cos(u);
                            p.y = (ringR + tubeR * Math.cos(v)) * Math.sin(u);
                            p.z = tubeR * Math.sin(v);
                            // Rotate to face camera
                            
                            if (Math.random() > 0.92) c.copy(CONFIG.colors.red); // Berries
                            else c.copy(CONFIG.colors.green);
                            break;

                        case 'hat': // Cone + Sphere tip + Ring base
                            const part = Math.random();
                            if (part < 0.7) { // Red Cone
                                const hh = Math.random() * 3;
                                const rr = (3 - hh) * 0.5; 
                                const th = Math.random() * Math.PI * 2;
                                // Bend the top
                                p.set(rr * Math.cos(th) + hh*0.2, hh - 1, rr * Math.sin(th));
                                c.copy(CONFIG.colors.red);
                            } else if (part < 0.85) { // White Base
                                const th = Math.random() * Math.PI * 2;
                                const rr = 1.5 + Math.random() * 0.3;
                                p.set(rr * Math.cos(th), -1.2 + Math.random()*0.4, rr * Math.sin(th));
                                c.copy(CONFIG.colors.white);
                            } else { // Pompom
                                const rBall = Math.random() * 0.4;
                                const th = Math.random() * Math.PI * 2;
                                const ph = Math.random() * Math.PI;
                                p.set(rBall * Math.sin(ph) * Math.cos(th) + 0.6, 2.0 + rBall * Math.cos(ph), rBall * Math.sin(ph) * Math.sin(th));
                                c.copy(CONFIG.colors.white);
                            }
                            break;

                        case 'cane': // Tube along curve
                            const t = Math.random() * Math.PI; // 0 to PI (hook) + straight part
                            const isHook = Math.random() > 0.6;
                            
                            if(isHook) {
                                // Hook part (Semi circle)
                                const ang = Math.random() * Math.PI;
                                const rad = 0.8;
                                const thick = 0.2 + Math.random()*0.1;
                                const circAng = Math.random() * Math.PI * 2;
                                p.x = 1.0 + (rad + thick*Math.cos(circAng)) * Math.cos(ang);
                                p.y = 1.0 + (rad + thick*Math.cos(circAng)) * Math.sin(ang);
                                p.z = thick * Math.sin(circAng);
                            } else {
                                // Straight part
                                const len = Math.random() * 3.5;
                                const thick = 0.2 + Math.random()*0.1;
                                const circAng = Math.random() * Math.PI * 2;
                                p.x = 1.0 + thick * Math.cos(circAng); // Offset x to match hook
                                p.y = 1.0 - len;
                                p.z = thick * Math.sin(circAng);
                            }
                            // Striping logic based on Y
                            if (Math.sin(p.y * 5 + p.x * 2) > 0) c.copy(CONFIG.colors.red);
                            else c.copy(CONFIG.colors.white);
                            break;

                        case 'heart': // Parametric
                            const ht = Math.random() * Math.PI * 2;
                            // Add volume
                            const hr = Math.random(); 
                            // 3D Heart approximation
                            const x = 16 * Math.pow(Math.sin(ht), 3);
                            const y = 13 * Math.cos(ht) - 5 * Math.cos(2*ht) - 2 * Math.cos(3*ht) - Math.cos(4*ht);
                            const z = (Math.random()-0.5) * 4; // Thickness
                            
                            p.set(x, y, z).multiplyScalar(0.15 * hr);
                            c.copy(CONFIG.colors.red);
                            break;
                    }

                    positions[i * 3] = p.x;
                    positions[i * 3 + 1] = p.y;
                    positions[i * 3 + 2] = p.z;
                    colors[i * 3] = c.r;
                    colors[i * 3 + 1] = c.g;
                    colors[i * 3 + 2] = c.b;
                }
                return { positions, colors };
            }
        };

        /**
         * üé® THREE.JS SETUP
         */
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffd700, 1, 20);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        // --- Main Particle System ---
        const particleGeometry = new THREE.BufferGeometry();
        // Initialize with first shape
        const initialData = ShapeFactory.generate('gift'); 
        
        // Attributes
        // 1. Current Position (used for rendering)
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(initialData.positions), 3));
        // 2. Color
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(initialData.colors), 3));
        
        // Stored Targets
        let targetPositions = new Float32Array(initialData.positions);
        let targetColors = new Float32Array(initialData.colors);
        
        // Scatter Velocities (computed on explosion)
        const velocities = new Float32Array(CONFIG.particleCount * 3);

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.08,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particleSystem);

        // --- Background Coins (Ambient) ---
        const coinGeo = new THREE.BufferGeometry();
        const coinPos = [];
        const coinCol = [];
        for(let i=0; i<CONFIG.coinCount; i++){
            coinPos.push((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*10 - 5);
            coinCol.push(1, 0.84, 0); // Gold
        }
        coinGeo.setAttribute('position', new THREE.Float32BufferAttribute(coinPos, 3));
        coinGeo.setAttribute('color', new THREE.Float32BufferAttribute(coinCol, 3));
        const coinMat = new THREE.PointsMaterial({ size: 0.15, vertexColors: true, transparent:true, opacity:0.6 });
        const coinsSystem = new THREE.Points(coinGeo, coinMat);
        scene.add(coinsSystem);

        // --- Webcam Plane (AR Background) ---
        // We render the webcam feed to a plane behind the scene if needed, 
        // but since we want the DOM video element to be hidden and processed, 
        // and a canvas background, we can just leave the renderer transparent 
        // and put the video behind the canvas in CSS.
        // However, prompt asks for AR. CSS Video background is easiest/fastest for fallback.
        // Let's attach the video stream to the video element.

        /**
         * üïπÔ∏è INTERACTION LOGIC
         */
        
        // Switch Shape Logic
        function switchShape(index) {
            STATE.currentShapeIndex = index;
            const shapeId = CONFIG.shapes[index].id;
            const data = ShapeFactory.generate(shapeId);
            
            // We just update the TARGET arrays. Animation loop handles the lerp.
            targetPositions.set(data.positions);
            targetColors.set(data.colors);
            
            updateOverlayText();
        }

        // Cycle shapes automatically if idle? No, let's bind it to mouse click / pinch release
        function nextShape() {
            let next = (STATE.currentShapeIndex + 1) % CONFIG.shapes.length;
            switchShape(next);
        }

        /**
         * ‚úã MEDIA PIPE SETUP
         */
        const videoElement = document.getElementById('input-video');
        const statusText = document.getElementById('status-text');
        const modeBadge = document.getElementById('mode-badge');

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onHandResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // Hand Detected
                if(STATE.interactionMode !== 'HAND') {
                    STATE.interactionMode = 'HAND';
                    modeBadge.innerText = "HAND MODE";
                    statusText.innerText = "Tracking Hand...";
                }

                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Rotation Control (using palm center ~ index 9)
                const palmX = landmarks[9].x; // 0-1
                const palmY = landmarks[9].y; // 0-1
                
                // Map to rotation (-1 to 1)
                const targetRotX = (palmY - 0.5) * 2; 
                const targetRotY = (palmX - 0.5) * 2;
                
                // Smooth damping
                STATE.rotationTarget.x = targetRotX;
                STATE.rotationTarget.y = targetRotY;

                // 2. Pinch Detection (Index Tip 8 to Thumb Tip 4)
                // Need 3D distance for accuracy, or simple 2D Euclidean
                const dx = landmarks[8].x - landmarks[4].x;
                const dy = landmarks[8].y - landmarks[4].y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                // Threshold logic
                // Typically pinch is < 0.05. Open hand > 0.1
                // Prompt: "pinch strength > 0.8" (MediaPipe doesn't give strength directly, we infer from distance inverse)
                
                // Normalize distance roughly: 0 (touching) to 0.2 (open)
                // Let's say touching (< 0.05) is "Pinch".
                if (dist < 0.06) {
                    if (!STATE.isScattering) {
                        STATE.isScattering = true;
                        triggerScatter();
                    }
                } else {
                    if (STATE.isScattering) {
                        STATE.isScattering = false;
                        triggerReassemble();
                    }
                }

            } else {
                // No hand results this frame
                // Don't immediately switch to mouse to prevent flickering, but keep state updated
            }
        }

        // Start Camera
        cameraUtils.start()
            .then(() => {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').remove(), 500);
                
                // Set video as background
                // We create a video texture for ThreeJS background or just use CSS
                // CSS is better for performance here, keeping canvas transparent
                videoElement.style.opacity = '1'; 
            })
            .catch(err => {
                console.error(err);
                statusText.innerText = "Camera Failed. Using Mouse.";
                modeBadge.innerText = "MOUSE MODE";
                document.getElementById('loader').style.display = 'none';
            });


        /**
         * üñ±Ô∏è MOUSE FALLBACK
         */
        document.addEventListener('mousemove', (e) => {
            if (STATE.interactionMode === 'MOUSE') {
                const x = (e.clientX / window.innerWidth) * 2 - 1;
                const y = -(e.clientY / window.innerHeight) * 2 + 1;
                STATE.rotationTarget.x = -y * 0.5;
                STATE.rotationTarget.y = x * 0.5;
            }
        });

        document.addEventListener('mousedown', () => {
            if (STATE.interactionMode === 'MOUSE') {
                STATE.isScattering = true;
                triggerScatter();
            }
        });

        document.addEventListener('mouseup', () => {
            if (STATE.interactionMode === 'MOUSE') {
                STATE.isScattering = false;
                triggerReassemble();
            }
        });

        // Trigger Functions
        function triggerScatter() {
            // Calculate random velocities for explosion effect
            const positions = particleGeometry.attributes.position.array;
            for(let i=0; i<CONFIG.particleCount; i++) {
                // Direction from center
                const px = positions[i*3];
                const py = positions[i*3+1];
                const pz = positions[i*3+2];
                
                // Normalized random direction + some outward bias
                velocities[i*3] = (Math.random()-0.5) * 0.5 + px * 0.1;
                velocities[i*3+1] = (Math.random()-0.5) * 0.5 + py * 0.1;
                velocities[i*3+2] = (Math.random()-0.5) * 0.5 + pz * 0.1;
            }

            // Text visual effect
            const greeting = document.getElementById('greeting-display');
            greeting.classList.add('active');
        }

        function triggerReassemble() {
            // Switch to next shape on release
            nextShape();
            
            const greeting = document.getElementById('greeting-display');
            greeting.classList.remove('active');
        }

        /**
         * üîÑ ANIMATION LOOP
         */
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. Handle Particle Movement
            const positions = particleGeometry.attributes.position.array;
            const colors = particleGeometry.attributes.color.array;

            // Damping / Speed factors
            const lerpFactor = 5.0 * dt; 
            const explosionSpeed = 10.0 * dt;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                if (STATE.isScattering) {
                    // Physics Scatter
                    positions[ix] += velocities[ix] * explosionSpeed;
                    positions[iy] += velocities[iy] * explosionSpeed;
                    positions[iz] += velocities[iz] * explosionSpeed;
                    
                    // Add some noise/wiggle
                    positions[ix] += Math.sin(time * 10 + i) * 0.01;
                } else {
                    // Reassemble (Lerp to Target)
                    // We also lerp colors
                    positions[ix] += (targetPositions[ix] - positions[ix]) * lerpFactor;
                    positions[iy] += (targetPositions[iy] - positions[iy]) * lerpFactor;
                    positions[iz] += (targetPositions[iz] - positions[iz]) * lerpFactor;

                    colors[ix] += (targetColors[ix] - colors[ix]) * lerpFactor;
                    colors[iy] += (targetColors[iy] - colors[iy]) * lerpFactor;
                    colors[iz] += (targetColors[iz] - colors[iz]) * lerpFactor;
                }
            }
            
            particleGeometry.attributes.position.needsUpdate = true;
            particleGeometry.attributes.color.needsUpdate = true;

            // 2. Handle Rotation
            // Smooth interpolate current rotation to target
            STATE.rotationCurrent.x += (STATE.rotationTarget.x - STATE.rotationCurrent.x) * 0.1;
            STATE.rotationCurrent.y += (STATE.rotationTarget.y - STATE.rotationCurrent.y) * 0.1;

            particleSystem.rotation.x = STATE.rotationCurrent.x;
            particleSystem.rotation.y = STATE.rotationCurrent.y;

            // 3. Ambient Coins Animation
            coinsSystem.rotation.y += 0.05 * dt;
            coinsSystem.rotation.z += 0.02 * dt;
            const cPos = coinsSystem.geometry.attributes.position.array;
            for(let i=0; i<CONFIG.coinCount; i++){
                // Float up/down
                cPos[i*3+1] += Math.sin(time + i)*0.01;
            }
            coinsSystem.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize Text
        updateOverlayText();

        // Start Loop
        animate();

    </script>
</body>
</html>
